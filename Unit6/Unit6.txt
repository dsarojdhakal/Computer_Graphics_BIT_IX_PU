

Unit 6: Light, Color and Shading

Introduction:
    Light, color, and shading are essential elements in computer graphics for creating realistic and understandable images.
    Light defines how objects are illuminated and how their surfaces interact with the environment.
    Color represents object appearance based on light reflection and absorption.
    Shading computes surface brightness using light source, material properties, and viewer position.
    These concepts help transform geometric models into visually meaningful graphics.
    They are widely used in engineering, simulation, animation, CAD, and scientific visualization.


Need for Shading in Engineering Data Visualization:
    Shading helps to represent the shape and depth of engineering objects clearly.
    It improves perception of surface orientation and curvature in 3D models.
    Shading distinguishes between different components and materials in complex assemblies.
    It enhances visibility of edges, holes, and structural features.
    Shading helps engineers analyze stress distribution, flow patterns, and surface continuity.
    It reduces ambiguity in flat wireframe or unshaded models.
    Shaded models allow faster interpretation of data and better design decisions.
    Shading is essential for accurate visualization in CAD, FEM, CFD, and simulation systems.


Algorithms to Simulate Ambient Reflection
    Ambient Reflection:
        Ambient reflection simulates uniform background light present throughout a scene and assumes 
        light is scattered equally in all directions.
        It does not depend on the position of the light source, surface orientation, or viewer position.
        Ambient reflection provides constant brightness across the entire surface and prevents objects 
        from appearing completely dark.
        It does not produce shadows or highlights and is computationally simple and efficient.
        Ambient reflection acts as a base lighting component and is usually combined with diffuse 
        and specular reflection models to ensure visibility in low-light regions.

    Ambient Reflection Algorithm (Basic Model):
        Step 1: Define ambient light intensity (Ia) as a constant value for the scene.
        Step 2: Define the ambient reflection coefficient (Ka) of the object surface.
        Step 3: Compute the ambient reflected intensity using the relation: 
                Ambient Intensity = Ia × Ka.
        Step 4: Apply the computed ambient intensity uniformly to all visible surface points.
        Step 5: Combine the ambient intensity with other illumination components if required.


Algorithms to Simulate Diffuse Reflection
    Diffuse Reflection:
        Diffuse reflection models light reflected uniformly from rough or matte surfaces.
        The reflected light depends on the angle between the incoming light direction and the surface normal.
        It follows Lambert’s cosine law, where:
            brightness is maximum when light strikes the surface directly.
        Diffuse reflection is independent of viewer position and produces smooth brightness variation across the surface.
        It gives objects a realistic, non-shiny appearance and does not produce sharp highlights.
        Diffuse reflection is essential for showing object shape, surface orientation, and depth.
        It is commonly combined with ambient and specular reflection models in illumination systems.

    Diffuse Reflection Algorithm (Lambertian Model):
        Step 1: Define diffuse light intensity of the source (Id).
        Step 2: Define diffuse reflection coefficient (Kd) of the surface material.
        Step 3: Determine the surface normal vector (N) at the point of illumination.
        Step 4: Determine the direction vector of the light source (L).
        Step 5: Compute the dot product between N and L.
        Step 6: If (N · L) < 0, set the diffuse intensity to zero.
        Step 7: Compute diffuse reflected intensity using the relation:
                Diffuse Intensity = Id × Kd × (N · L).
        Step 8: Apply the computed diffuse intensity to the surface point.


Algorithms to Simulate Specular Reflection
    Specular Reflection:
        Specular reflection is used to models mirror-like reflection from smooth surfaces, 
        It produce bright highlights on shiny objects.
        The reflected light depends on the viewer position, surface smoothness, and surface orientation.
        Specular reflection follows the Phong reflection model, 
        where higher shininess values produce smaller, sharper highlights and 
        lower values produce broader highlights.
        It is used to represent shiny materials like metal and plastic, enhancing realism in 3D graphics.
        Specular reflection is commonly combined with ambient and diffuse reflection in 
        illumination models to produce complete and realistic lighting.

    Specular Reflection Algorithm (Phong Model):
        Step 1: Define specular light intensity of the source (Is).
        Step 2: Define specular reflection coefficient (Ks) of the surface material.
        Step 3: Define shininess exponent (n) to control highlight sharpness.
        Step 4: Determine the surface normal vector (N) at the point.
        Step 5: Determine the light direction vector (L).
        Step 6: Compute the reflection vector (R) using surface normal and light direction.
        Step 7: Determine the viewer direction vector (V).
        Step 8: Compute the dot product between R and V.
        Step 9: If (R · V) < 0, set the specular intensity to zero.
        Step 10: Compute specular reflected intensity using the relation: 
                 Specular Intensity = Is × Ks × (R · V)^n.
        Step 11: Apply the calculated intensity to the surface point.


Constant Shading Model (Flat Shading)
    Constant Shading:
        Constant shading assigns a single intensity value to an entire surface or polygon, assuming uniform illumination.
        The shading value is calculated once per polygon, and all pixels are filled with the same color.
        It is simple and fast, easy to implement, and suitable for real-time rendering.
        It is used for basic models where performance is more important than visual quality.
        Constant shading does not produce smooth transitions across adjacent polygons, 
        does not account for variations on curved surfaces, and is less realistic for detailed or smooth objects.
        It is used in basic rendering systems and previewing models.

    Algorithm for Constant Shading:
        Step 1: Select a representative point on the polygon, usually the center or any vertex.
        Step 2: Compute the surface normal vector for the polygon.
        Step 3: Apply the illumination model (ambient + diffuse + specular) at the selected point.
        Step 4: Calculate the intensity value using the computed lighting.
        Step 5: Assign this single intensity value to all pixels of the polygon.


Gouraud Shading Model

    Gouraud Shading:
        Gouraud shading is a smooth shading technique that improves surface realism by performing lighting calculations at the vertices of polygons and interpolating intensity values across the surface.
        It produces smooth color transitions, reduces visible edges between polygons, and is efficient for real-time graphics.
        Specular highlights may be weak or missed, and the accuracy depends on vertex intensity.
        It is less suitable for very small or sharp highlights.
        Gouraud shading is widely used in real-time rendering, games, CAD, and engineering visualization where a balance between performance and smooth appearance is needed.

    Algorithm for Gouraud Shading:
        Step 1: Compute normal vectors at each vertex of the polygon (N1, N2, N3...).
        Step 2: Apply the illumination model at each vertex to calculate vertex intensity:
                I_vertex = Ia × Ka + Id × Kd × (N · L) + Is × Ks × (R · V)^n
                where   Ia = ambient light intensity, 
                        Ka = ambient reflection coefficient,
                        Id = diffuse intensity, 
                        Kd = diffuse reflection coefficient,
                        Is = specular intensity, 
                        Ks = specular reflection coefficient,
                        N = vertex normal, 
                        L = light direction, 
                        R = reflection vector,
                        V = viewer vector, 
                        n = shininess exponent.
        Step 3: Interpolate vertex intensity along polygon edges (I_edge) and across scan lines (I_pixel).
        Step 4: Assign interpolated intensity I_pixel to each pixel.


Phong Shading Model
    Phong Shading:
        Phong shading is a per-pixel shading technique that improves realism by interpolating vertex normals across the polygon and computing lighting at each pixel.
        It produces smooth shading and accurate specular highlights, making it ideal for shiny or curved surfaces.
        It is computationally more expensive than Gouraud shading due to per-pixel calculations.
        Phong shading is widely used in high-quality rendering, CAD, product visualization, games, and simulations where realism is important.

    Algorithm for Phong Shading:
        Step 1: Compute normal vectors at each vertex of the polygon (N1, N2, N3...).
        Step 2: Interpolate the vertex normals across the polygon to get the normal N at each pixel.
        Step 3: Normalize the interpolated normal N at each pixel.
        Step 4: Determine the light direction vector L and viewer direction vector V for each pixel.
        Step 5: Compute the reflection vector R = 2(N · L)N - L.
        Step 6: Apply the Phong illumination model at each pixel:
                I_pixel = Ia × Ka + Id × Kd × (N · L) + Is × Ks × (R · V)^n
                where   Ia = ambient light intensity, 
                        Ka = ambient reflection coefficient,
                        Id = diffuse intensity, 
                        Kd = diffuse reflection coefficient,
                        Is = specular intensity, 
                        Ks = specular reflection coefficient,
                        N = pixel normal, 
                        L = light direction, 
                        R = reflection vector,
                        V = viewer vector, 
                        n = shininess exponent.
        Step 7: If (N · L) < 0 or (R · V) < 0, set respective diffuse or specular intensity to zero.
        Step 8: Assign the computed intensity I_pixel to the pixel.
